1. Rust中，if和match能够生成值嘛？
2. 为什么Rust没有类似于C中的三元运算符呢？
3. C中大多控制流工具是什么？Rust呢？
4. Rust，一个块，以;结尾，返回值是什么？
5. Rust，一个块，没有;结尾，返回值是什么？
6. Rust，表达式之一，是块，一个块有值嘛？是什么？
7. let声明中，类型提示是必须的嘛？初始化代码是必须的嘛？分号是必须的嘛？
8. let name; name = "hello".to_owned(); println!("{:?}",name);可以编译通过嘛？name明明不可变，为什么还可以name = "hello".to_owned();呢？
9. 编写if-else语句。
10. 编写if-else if-else语句。
11. 编写match语句。
12. 结合向量的pop方法，编写match语句。
13. match表达式的所有分支，都必须具有相同的类型嘛？
14. if-else if-else表达式的所有分支，都必须有相同的类型嘛？
15. match必须覆盖所有可能分支嘛？match匹配到该项之后，还会继续向下匹配嘛？
16. if-let表达式的作用？举例，用match改写。
17. 写出已学会的循环。
18. Rust，break可以用在match表达式中嘛？
19. 在循环中使用break + 返回值。
20. 循环中，if和else的break，都必须有相同的类型嘛？
21. 循环中，使用continue表达式。
22. 两层循环，break退出外层循环。
23. 两层循环，break退出内层循环。
24. 两层循环，continue继续外层循环。
25. 两层循环，continue继续内层循环。
26. 不带值的return，默认返回什么？
27. 发散函数的用途。
28. Rust有类似于C中的自增、自减运算符嘛？
29. let mut tmpv = vec!['a', 'b', 'c', 'd', 'e'];
tmpv[..]表示什么？
tmpv[..3]呢？
tmpv[1..]呢？
tmpv[1..3]呢？
tmpv[..=3]呢？
tmpv[1..=3]呢？
30. 1..3包含哪些数值？
1..=3包含哪些数值？
31. 如何访问结构体、元组、数组？
struct Node { sx1 : String, sx2 : i32 };
let node = Node { sx1 : "hab".to_owned(), sx2 : 212 };
println!("{:?}", node.sx1);
let tmp = ("hab".to_owned(), 2121);
println!("{:?}", tmp.1);
let sz = [1, 2, 3, 4];
println!("{:?}", sz[1]);
32. 计算：
23+12	23.1+12.9	true && false
23-12	23.1-12.9		true || false
23*12	23.1*12.9
23/12	23.1/12.9
23%12	23.1%12.9
23&12
23|12
23^12
23<<2
23>>2
!23
23==12	23.1==12.9
23!=12	23.1!=12.9
23<12	23.1<12.9
23<=12	23.1<=12.9
23>12	23.1>12.9
23>=12	23.1>=12.9
33. Rust有类似于C中的自增或者自减运算嘛？
34. 如果一个变量类型是copy的，那么用这个变量去赋值，所有权移动嘛？如果不是copy的，用这个变量去赋值，所有权移动嘛？
35. Rust内的内置数值类型可以相互转化嘛？
let x = 17;
println!("{} {} {} {} {} {} {}", x, x as u8, x as u16, x as u32, x as u64, x as u128, x as usize);
println!("{} {} {} {} {} {} {} {}", x as i8, x as i16, x as i32, x as i64, x as i128, x as isize, x as f32, x as f64);
let y = 12.92;
println!("{} {} {} {} {} {} {}", y, y as u8, y as u16, y as u32, y as u64, y as u128, y as usize);
println!("{} {} {} {} {} {} {} {}", y as i8, y as i16, y as i32, y as i64, y as i128, y as isize, y as f32, y as f64);
36. bool、char类型可以转为整型嘛？可以反过来吗？
let x = true;
println!("{} {} {} {} {} {} {} {} {} {} {} {} {}", x, x as u8, x as u16, x as u32, x as u64, x as u128, x as usize, 
x as i8, x as i16, x as i32, x as i64, x as i128, x as isize);
let y = 'c';
println!("{} {} {} {} {} {} {} {} {} {} {} {} {}", y, y as u8, y as u16, y as u32, y as u64, y as u128, y as usize, 
y as i8, y as i16, y as i32, y as i64, y as i128, y as isize);
let z : u8= 97;
println!("{}", z as char);
37. 有哪些默认的隐式解引用呢？
38. 闭包是什么呢？
39. 使用else if，如果n可以被2整除，那么返回12；如果n可以被3整除，那么返回13；否则返回17
40. 使用else if，如果n可以被2整除，那么返回12；如果n可以被3整除，那么返回13；否则返回17
41. 编写factorial函数
42. 编写factorial函数
43. 使用while循环编写factorial函数
44. 使用while循环编写factorial函数
45. 使用for循环编写factorial函数
46. 使用for循环编写factorial函数


1. Rust中，if和match能够生成值。
2. if能生成值，if和else足够了。
3. C中大多控制流工具是语句，Rust中是表达式。
4. ()
5. 表达式的值
6. ;结尾是空元组，无;结尾是表达式的值
7. 类型提示不必须 初始化代码不必须 分号必须
8. 可以编译通过 延迟初始化这是，因为name还没有初始化
9. let a = 3;
let b = if a == 3 { "a==3".to_owned() }
else { "a!=3".to_owned() };
println!("{:?}", b);
10. let a = 3;
let b = if a == 3 { "a==3".to_owned() }
else if a == 2 { "a==2".to_owned() }
else { "a!=3 && a!=2".to_owned() };
println!("{:?}", b);
11. let code = 3;
let result = match code {
0 => "OK".to_owned(),
1 => "Wires Tangled".to_owned(),
2 => "User Asleep".to_owned(),
_ => "Unrecognized Error".to_owned()
};
println!("{:?}", result);
12. 
let mut tmpv = vec!["hello".to_owned(), "world".to_owned(), "what".to_owned()];
while true {
	let res = match tmpv.pop() {
		Some(item) => item,
		None => "None".to_owned()
	};
	if res != "None" {
		println!("{:?}", res);
	}
	else { break; }
}
13. 是
14. 是
15. 是 不会再继续向下匹配
16. 从Option或者Result中获取数据
let mut tmpv = vec!['a', 'b', 'c', 'd'];
while true {
	if let Some(item) = tmpv.pop() {
		println!("{:?}", item);
	}
	else { break; }
}
用match改写之后：
let mut tmpv = vec!['a', 'b', 'c', 'd'];
while true {
	match tmpv.pop() {
		Some(item) => println!("{:?}", item),
		None => break
	}
}
17. 
let tmpv = vec!["a".to_owned(), "b".to_owned(), "c".to_owned()];
for item in &tmpv {
	println!("{:?}", item);
}
或者
let tmpv = vec!["a".to_owned(), "b".to_owned(), "c".to_owned()];
for i in 0..tmpv.len() {
	println!("{:?}", tmpv[i]);
}
或者
let tmpv = vec!["a".to_owned(), "b".to_owned(), "c".to_owned()];
let mut i = 0;
while i < tmpv.len() {
	println!("{:?}", tmpv[i]);
	i+=1;
}
或者
let tmpv = vec!["a".to_owned(), "b".to_owned(), "c".to_owned()];
let mut i = 0;
loop {
	if i < tmpv.len() {
		println!("{:?}", tmpv[i]);
		i+=1;
	}
	else { break; }
}

18. 不能
19. let mut i = 1;
let tmp = loop {
	i *= 2;
	if i > 1000 {
		break i;
	}
};
println!("{:?}", tmp);
或者
let mut tmpv = vec!["abc".to_owned(), "bbbb".to_owned(), "cdas".to_owned()];
let tmp = loop {
	if let Some(item) = tmpv.pop() {
		if item == "bbbb" {
			break item;
		}
	}
	else {
		break "None".to_owned();
	}
};
println!("{:?}", tmp);
20. 是
21. let mut count = 0;
for i in 0..20 {
	if i%2==0 {
		count += 1;
	}
	else {
		continue;
	}
}
println!("{:?}", count);
22. 
'a: for i in 0..=5 {
	'b: for j in 0..=5 {
		if i + j < 7 {
			println!("a={}, b={}", i, j);
		}
		else {
			break 'a;
		}
	}
}
23. 
'a: for i in 0..=5 {
	'b: for j in 0..=5 {
		if i + j < 7 {
			println!("a={}, b={}", i, j);
		}
		else {
			break 'b;
		}
	}
}
24. 
'a: for i in 0..=5 {
	'b: for j in 0..=5 {
		if i % 2 != 0 {
			continue 'a;
		}
		else {
			println!("a={}, b={}", i, j);
		}
	}
}
25.
'a: for i in 0..=5 {
	'b: for j in 0..=5 {
		if j % 2 == 0 {
			continue 'b;
		}
		else {
			println!("a={}, b={}", i, j);
		}
	}
}
26. 不带值的return，默认返回空元组()。
27. 未明确返回值的函数。
28. 没有；
29. 
tmpv[..]，'a', 'b', 'c', 'd', 'e'
tmpv[..3]，'a', 'b', 'c'
tmpv[1..]，'b', 'c', 'd', 'e'
tmpv[1..3]，'b', 'c'
tmpv[..=3]，'a', 'b', 'c', 'd'
tmpv[1..=3]，'b', 'c', 'd'
30. 1, 2
1, 2, 3
31. node.sx1 tmp.1 sz[1]
32. 
println!("{:?}", 23+12);
println!("{:?}", 23-12);
println!("{:?}", 23*12);
println!("{:?}", 23/12);
println!("{:?}", 23%12);
println!("{:?}", 23&12);
println!("{:?}", 23|12);
println!("{:?}", 23^12);
println!("{:?}", 23<<2);
println!("{:?}", 23>>2);
println!("{:?}", !23);
println!("{:?}", 23==12);
println!("{:?}", 23!=12);
println!("{:?}", 23<12);
println!("{:?}", 23<=12);
println!("{:?}", 23>12);
println!("{:?}", 23>=12);
println!("{:?}", 23.1+12.9);
println!("{:?}", 23.1-12.9);
println!("{:?}", 23.1*12.9);
println!("{:?}", 23.1/12.9);
println!("{:?}", 23.1%12.9);
println!("{:?}", 23.1==12.9);
println!("{:?}", 23.1!=12.9);
println!("{:?}", 23.1<12.9);
println!("{:?}", 23.1<=12.9);
println!("{:?}", 23.1>12.9);
println!("{:?}", 23.1>=12.9);
println!("{:?}", true && false);
println!("{:?}", true || false);
33. 没有
34. copy类型，不移动 不是copy类型，移动
35. Rust内的内置数值类型可以相互转化
36. bool、char可以转为整型 不能反过来，但例外是u8转char
37. &String默认转为&str
&Vec[T]默认转为&[T]
&Box<T>默认转为&T
38. 闭包是轻量级函数
39. 
if n%2 == 0 { 12 }
else if n%3 == 0 { 13 }
else { 17 }
40. 
if n%2 == 0 { 12 }
else if n%3 == 0 { 13 }
else { 17 }
41. fn factorial(n : u32) -> u32 {
if n == 0 { 1 }
else if n == 1 { 1 }
else { n*factorial(n-1) }
}
42. fn factorial(n : u32) -> u32 {
if n == 0 { 1 }
else if n == 1 { 1 }
else { n*factorial(n-1) }
}
43. 
fn factorial(n: u32) -> u32 {
    if n == 0 { 1 }
    else if n == 1 { 1 }
    else {
        let mut mutn = n;
        let mut res = 1;
        while mutn != 1 {
            res *= mutn;
            mutn -= 1;
        }
        res
    }
}
44. 
fn factorial(n: u32) -> u32 {
    if n == 0 { 1 }
    else if n == 1 { 1 }
    else {
        let mut mutn = n;
        let mut res = 1;
        while mutn != 1 {
            res *= mutn;
            mutn -= 1;
        }
        res
    }
}
45. 
fn factorial(n: u32) -> u32 {
    if n == 0 { 1 }
    else if n == 1 { 1 }
    else {
        let mut res = 1;
        for i in 1..=n {
            res *= i;
        }
        res
    }
}
46. 
fn factorial(n: u32) -> u32 {
    if n == 0 { 1 }
    else if n == 1 { 1 }
    else {
        let mut res = 1;
        for i in 1..=n {
            res *= i;
        }
        res
    }
}
1. 如何查看Rust管理器cargo版本呢？
2. 如何查看Rust管理器cargo版本呢？
3. 如何查看Rust编译器rustc版本呢？
4. 如何查看Rust编译器rustc版本呢？
5. 如何查看Rust文档工具rustdoc版本呢？
6. 如何查看Rust文档工具rustdoc版本呢？
7. 如何得知某一类型的位数？
8. u8、i8、u16、i16多少位？std::mem::size_of::<u8>()、std::mem::size_of::<i8>()的值分别是多少？
9. u32、i32、f32、u64、i64、f64多少位？std::mem::size_of::<u32>()、std::mem::size_of::<i32>()、std::mem::size_of::<f32>()、std::mem::size_of::<u64>()、std::mem::size_of::<i64>()、std::mem::size_of::<f64>()的值分别是多少？
10. i128、u128、isize、usize多少位？std::mem::size_of::<i128>()、std::mem::size_of::<u128>()、std::mem::size_of::<isize>()、std::mem::size_of::<usize>()的值分别是多少？
11. 42u8、11126i32、72u8、1.234f32的类型？
12. 192u16、91.1232f64、91.123f32的类型？
13. 192、168、32的类型？
14. 0x123、0xd34、0x15a的值？
15. 0o151、0o732、0o113的值？
16. 0b10101、0b11101、0b11111的值？
17. 规范书写4294967295、42949672951。
18. b'A'、b'B'、b'\''、b'\\'、b'\n'、b'\r'、b'\t'分别等效于什么？
19. 求2^4、3^3、|-123|的值，接着再求0x123的二进制表示中1的个数
20. 求(-2)^5、12^3、|-120|的值，接着再求0xff的二进制表示中1的个数
21. 使用assert_eq!()来判断10_i8和10_u16是否相等。
22. 判断2525_u16和2525_i16是否相等。
23. 判断-1_i16和-1_i32是否相等。
24. 判断65535_u16和65535_i32是否相等。
25. 判断1000_i16和232_u8是否相等。
26. 判断65535_u32和-1_i16是否相等。
27. 判断-1_i8和255_u8是否相等。
28. 判断255_u8和-1_i8是否相等。
29. 在调试构建时，下面代码可以编译通过，但在实际运行时，会提示乘法溢出，请问如何做，才能避免乘法溢出呢？
fn main() {
	let mut i = 1;
	let mut tmp : i32 = 20;
	while i <= 10 {
		i += 1;
		println!("{}", i);
		tmp = tmp * 100;
		println!("{}", tmp);
	}
}
30. 在调试构建过程中，出现整型算术运算溢出时，Rust会怎么样？在发布构建中，出现这个问题时，Rust又会怎么样？
31. 检查运算，判断u8数据类型可不可以保存10+20的结果。
32. 判断u8数据类型可不可以保存100+200的结果。
33. 判断i8数据类型可不可以保存(-128)/(-1)的结果。
34. 整型数字的检查运算方法，比如checked_add、checked_sub、checked_mul、checked_div、checked_rem，如果没有溢出，那么会返回什么呢？如果会溢出，那么会返回什么呢？
35. 为什么i8数据类型不能保存(-128)/(-1)的结果呢？
36. 计算100*200回绕到i16的结果；
37. 计算500*500回绕到u16的结果；
38. 计算500*500回绕到i16的结果；
39. 计算5左移17位回绕到i16的结果；
40. 计算5右移17位回绕到i16的结果；
41. 饱和计算500*500到u16的结果；
42. 饱和计算32760加上10到i16的结果；
43. 饱和计算-32760减去10到i16的结果；
44. 饱和计算500*500到u16的结果；
45. 饱和计算适用于位移、除法、取余嘛？
46. 判断u8类型的255减去2之后，会不会溢出，为什么？
47. 判断u8类型的255加上2之后，会不会溢出，为什么？
48. 判断i32类型的0x_7FFF_FFFF加上1之后，会不会溢出，为什么？
49. 判断u16类型的5左移17位之后，会不会溢出，为什么？
50. 判断i8类型的100加上27之后，会不会溢出，为什么？
51. 判断u8类型的10减去11之后，会不会溢出，为什么？
52. 判断u8类型的128乘以3之后，会饱和得到什么结果，为什么？
53. 判断u16类型的64除以8之后，会回绕得到什么结果，为什么？
54. 判断i16类型的-32768对-1取余之后，会回绕得到什么结果，为什么？
55. 判断i8类型的-128取负之后，会不会溢出，为什么？
56. 判断i16类型的-32768求绝对值之后，得到的结果会不会溢出，为什么？
57. 判断u8类型的3进行4次幂操作之后，得到的结果会不会溢出，为什么？
58. 判断u32类型的10左移34位之后，得到的结果会不会溢出，为什么？
59. 判断u64类型的40右移66位之后，得到的结果会不会溢出，为什么？
60. 不同类型的整型数之间能进行计算嘛？
61. 不同类型的整型数之间能进行计算嘛？
62. 开发环境中计算溢出时，会自动回绕嘛？
63. 开发环境中计算溢出时，会自动回绕嘛？


1. cargo --version
2. cargo --version
3. rustc --version
4. rustc --version
5. rustdoc --version
6. rustdoc --version
7. std::mem::size_of::<i32>()
8. 8 8 16 16 1 1
9. 32 32 32 64 64 64 4 4 4 8 8 8
10. 128 128 64 64 16 16 8 8
11. u8 i32 u8 f32
12. u16 f64 f32
13. i32 i32 i32
14. 291 3380 346
15. 105 474 75
16. 21 29 31
17. 42_9496_7295_u32、429_4967_2951_i64或者429_4967_2951_u64
18. 65 66 39 92 10 13 9
19. println!("{}", 2_i32.pow(4));
println!("{}", 3_i32.pow(3));
println!("{}", (-123_i32).abs());
println!("{}", (0x123_i32).count_ones());
20. println!("{}", (-2_i32).pow(5));
println!("{}", 12_i32.pow(3));
println!("{}", (-120_i32).abs());
println!("{}", 0xff_i32.count_ones());
21. assert_eq!(10_i8 as u16, 10_u16);
22. assert_eq!(2525_u16 as i16, 2525_i16);
23. assert_eq!(-1_i16 as i32, -1_i32);
24. assert_eq!(65535_u16 as i32, 65535_i32);
25. assert_eq!(1000_i16 as u8, 232_u8);
26. assert_eq!(65535_u32 as i16, -1_i16);
27. assert_eq!(-1_i8 as u8, 255_u8);
28. assert_eq!(255_u8 as i8, -1_i8);
29. tmp = tmp.wrapping_mul(100);
或者if tmp.checked_mul(100) != None { tmp *= 100; } else { break; }
或者if let Some(res) = tmp.checked_mul(100) { tmp = res; } else { break; }
30. 出现panic 运算会回绕
31. assert_eq!(10_u8.checked_add(20), Some(30));
32. assert_eq!(100_u8.checked_add(200), None);
33. assert_eq!((-128)_i8.checked_div(-1), None);
34. 表示确实存在某个值的Some() None
35. 因为i8可表示的最大正整数是127
36. println!("{}", 100_i16.wrapping_mul(200));
37. println!("{}", 500_u16.wrapping_mul(500));
38. println!("{}", 500_i16.wrapping_mul(500));
39. println!("{}", 5_i16.wrapping_shl(17));
40. println!("{}", 5_i16.wrapping_shr(17));
41. println!("{}", 500_u16.saturating_add(500));
42. println!("{}", 32760_i16.saturating_add(10));
43. println!("{}", (-32760_i16).saturating_sub(10));
44. println!("{}", 500_i16.saturating_mul(500));
45. 饱和计算不适用于位移、除法、取余
46. println!("{:?}", 255_u8.overflowing_sub(2));
不会溢出，因为253可被u8表示
47. println!("{:?}", 255_u8.overflowing_add(2));
会溢出，因为257不可被u8表示
48. println!("{:?}", 0x_7FFF_FFFF_i32.overflowing_add(1));
会溢出，因为2147483648不可被i32表示
49. println!("{:?}", 5_u16.overflowing_shl(17));
会溢出，17位甚至超出了u16的16位
50. println!("{}", 100_i8.checked_add(27)==Some(127));
不会溢出，127可被i8表示
51. println!("{}", 10_u8.checked_sub(11)==None);
会溢出，-1不可被u8表示
52. println!("{}", 128_u8.saturating_mul(3)==255);
会溢出，因为384不可被u8表示
53. println!("{}", 64_u16.wrapping_div(8)==8);
不会溢出，8可被u16表示
54. println!("{}", (-32768_i16).wrapping_rem(-1)==0);
会溢出，因为(-32768)/(-1)=32768的32768不可被i16表示
55. println!("{}", (-128_i8).checked_neg()==None);
会溢出，128不可被i8表示
56. println!("{}", (-32768_i16).wrapping_abs()==-32768);
会溢出，32768不可被i16表示
57. println!("{}", 3_u8.checked_pow(4)==Some(81));
不会溢出，81可被u8表示
58. println!("{}", 10_u32.wrapping_shl(34)==40);
会溢出，34位大于32位
59. println!("{}", 40_u64.wrapping_shr(66)==10);
会溢出，66大于64位
60. 不同类型的整型数之间不能进行计算
61. 不同类型的整型数之间不能进行计算
62. 开发环境中溢出时，不会自动进行回绕，而是会panic报错
63. 开发环境中溢出时，不会自动进行回绕，而是会panic报错
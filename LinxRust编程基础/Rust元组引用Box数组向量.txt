1. let tmp = 34_u32.overflowing_sub(35);，已知整型数的overflowing_sub()方法返回一个元组，依次输出这个元组的值。
2. let text = "Hello World!";，已知split_at方法返回一个元组。使用该方法，依次输出这个元组的值。
3. 将split_at返回到两个变量。
4. 将overflowing_sub返回到两个变量。
5. 不返回值的函数的返回类型是什么？
6. 不返回值的函数的返回类型是什么？
7. Rust一个变量可以同时有多个共享引用和可变引用嘛？可以同时有多个共享引用嘛？可以同时有多个可变引用嘛？
8. 在堆中分配值的最简单方式是什么？
9. 初始化一个长为9的u32数组。
10. 初始化一个长为1000的bool数组。
11. 计算一个数组的长度。
12. 计算10题中数组长度。
13. 输出数组中第一个元素的值。
14. 输出数组中第二个元素的值。
15. 数组索引可以是u8类型的0嘛？
16. 数组索引可以是u64类型的0嘛？
17. 初始化一个1KB的缓冲区。
18. 可以使用未初始化的数组嘛？
19. 数组的长度在什么时候确定的？编译期还是运行期？
20. 排列一个整型数组
21. 数组被分配在哪儿？向量被分配在哪儿？
22. 定义一个向量，初始化为[2, 3, 5, 7]。
23. 定义一个向量，初始化为["Hello", "World", "How", "Are", "You", "Are", "You", "Ok"]。
24. 定义一个向量，初始化为['α', 'β', 'ε']。
25. 向整型向量中添加元素32。
26. 向字符串向量中添加元素"epsilon"。
27. 向字符向量中添加元素'A'。
28. 计算整型向量每个元素的乘积。
29. 初始化一个1KB的可变缓冲区。
30. 初始化一个长为1000的可变bool数组，用true初始化。
31. 创建一个空向量，接着将1、2、3压入其中。
32. 创建一个空向量，接着将"Hello"、"World"、"What"压入其中。
33. 反转整型向量；
34. 反转字符串向量；
35. 生成一个100到239的u32类型的向量；
36. 生成一个1到1000的i32类型的向量；
37. 为什么collect返回到变量，需要明确类型？
38. 向量Vec<T>由几个值组成？缓冲区达到最大容量时，会做什么？
39. 预先创建一个大小为2的向量，输出其长度和容量。
40. 向向量中压入几个元素，再输出其长度和容量。
41. 给向量排序、翻转向量。
42. 向向量指定位置中插入元素。
43. 将向量分裂成两个向量引用。
44. 移除向量中的第一个元素。
45. 移除向量中的最后一个元素。
46. 弹出向量中一个值。
47. 再弹出向量中一个值。
48. for循环遍历向量中每个元素。
49. for循环遍历命令行参数。


1. let tmp = 34_u32.overflowing_sub(35);
println!("{}", tmp.0);
println!("{}", tmp.1);
2. let text = "Hello World!";
let tmp = text.split_at(5);
println!("{}", tmp.0);
println!("{}", tmp.1);
3. let text = "Hello World!";
let (tmp1, tmp2) = text.split_at(5);
println!("{} {}", tmp1, tmp2);
4. let (tmp1, tmp2) = 34_u32.overflowing_sub(35);
println!("{}\n{}", tmp1, tmp2);
5. 空元组
6. 空元组
7. 不可以同时多个共享引用和可变引用
可以同时多个共享引用
不可以同时多个可变引用
8. 使用Box::new
9. let a : [u32; 9] = [1, 2, 3, 4, 5, 6, 7, 8, 9];
10. let b = [true; 1000];
11. println!("{}", a.len());
12. println!("{}", b.len());
13. println!("{}", a[0]);
14. println!("{}", a[1]);
15. 不可以，数组索引必须是usize类型
16. 不可以，数组索引必须是usize类型
17. let a = [0u8; 1024];
18. 不可以，反定义的都是初始化了的
19. 编译期
20. let mut a : [u32; 10] = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0];
a.sort();
println!("{:?}", a);
21. 数组被分配在栈上，向量被分配在堆上
22. let mut a = vec![2, 3, 5, 7];
println!("{:?}", a);
23. let mut a = vec!["Hello", "World", "How", "Are", "You", "Are", "You", "Ok"];
println!("{:?}", a);
24. let mut a = vec!['α', 'β', 'ε'];
println!("{:?}", a);
25. a.push(32);
26. a.push("epsilon");
27. a.push('A');
28. println!("{}", a.iter().product::<i32>());
29. let mut a = vec![0; 1024];
30. let mut a = vec![true; 1000];
31. let mut a = Vec::new();
a.push(1); a.push(2); a.push(3);
32. let mut a = Vec::new();
a.push("Hello"); a.push("World"); a.push("What");
33. a.reverse();
34. a.reverse();
35. let a : Vec<u32> = (100..239).collect();
println!("{:?}", a);
36. let a : Vec<i32> = (1..1000).collect();
println!("{:?}", a);
37. 因为collect不光能返回向量
38. 3 指向堆中缓冲区的指针、缓冲区能存储的元素数量、实际包含的数量
重新分配倍大空间，复制，释放
39. let mut v : Vec<i32> = Vec::with_capacity(2);
println!("{}", v.len());
println!("{}", v.capacity());
40. let mut v : Vec<i32> = Vec::with_capacity(2);
v.push(1);
v.push(2);
println!("{} {}", v.len(), v.capacity());
v.push(0);
println!("{} {}", v.len(), v.capacity());
41. let mut v : Vec<i32> = vec![1, 9, 0];
println!("{:?}", v);
v.sort();
println!("{:?}", v);
v.reverse();
println!("{:?}", v);
42. let mut v : Vec<i32> = vec![1, 11, 0];
println!("{:?}", v);
v.insert(2, 10101);
println!("{:?}", v);
43. let mut v : Vec<i32> = vec![1, 11, 0];
println!("{:?}", v);
v.insert(2, 10101);
println!("{:?}", v);
let (tmp1, tmp2) = v.split_at(3);
println!("{:?} {:?}", tmp1, tmp2);
44. let mut v : Vec<i32> = vec![1, 11, 0];
println!("{:?}", v);
v.remove(0);
println!("{:?}", v);
45. let mut v : Vec<i32> = vec![1, 11, 0];
println!("{:?}", v);
v.remove(v.len()-1);
println!("{:?}", v);
46. let mut v : Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
println!("{:?}", v);
if let Some(res) = v.pop() { println!("{}", res); } else { println!("No"); }
47. if let Some(res) = v.pop() { println!("{}", res); } else { println!("No"); }
48. let mut v : Vec<i32> = vec![1, 2, 3, 4];
for i in v {
println!("{}", i);
}
49. let v : Vec<String> = std::env::args().skip(1).collect();
for i in v {
println!("{:?} {:?}", i, if i.len() % 2 == 0 { "sh" } else { "dan" });
}